\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{float}
\usepackage{braket}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\usetikzlibrary{quantikz}
\usepackage{cite}

\title{\textbf{Solving the Standard Cantilever Problem Using Quantum Computing Algorithms }}
\author{Mohammed Rehan Tadpatri,  Mohammed Shehin K T, Razi Mohammed}
\date{\today}

\begin{document}

\maketitle
\begin{center}
\textbf{Project Repository:} \href{https://github.com/astroanax/quantum-fea}{github.com/astroanax/QUANTUM-FEA}
\end{center}

\begin{abstract}
This report presents a comprehensive implementation of quantum finite element analysis for the structural mechanics problem of cantilever beam deflection. The work combines classical finite element discretization using Euler-Bernoulli beam theory with quantum linear system solvers based on the Harrow-Hassidim-Lloyd (HHL) algorithm\footnote{\url{https://dojo.qulacs.org/en/latest/notebooks/7.2_Harrow-Hassidim-Lloyd_algorithm.html}}. The implementation employs proper quantum phase estimation with an 8-qubit precision register to extract eigenvalues from the global stiffness matrix, followed by controlled rotation operations to achieve matrix inversion on a quantum computer. Results demonstrate that the quantum solution achieves less than 0.001\% relative error compared to classical finite element methods, with visualization capabilities through the Visualization Toolkit (VTK) format for ParaView. The complete implementation comprise about 500 lines of Python code that uses the Cirq quantum computing framework.
\end{abstract}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{paraview-demo.png}
    \caption{Results of analyzing load of 300kN on a steel cantilever beam of length 1m,  and cross-sectional area of $0.01m^2$}
    \label{fig:paraview-demo}
\end{figure}
\newpage
\tableofcontents
\section{Introduction}

The finite element method has served as the cornerstone of computational mechanics for over half a century, enabling engineers to solve complex structural analysis problems that would be intractable through analytical means alone. At its core, the finite element method transforms a continuum mechanics problem governed by partial differential equations into a discrete system of linear algebraic equations of the form $\mathbf{K}\mathbf{u} = \mathbf{f}$, where $\mathbf{K}$ represents the global stiffness matrix, $\mathbf{u}$ contains the nodal displacements, and $\mathbf{f}$ represents the applied forces. For large-scale engineering problems involving millions of degrees of freedom, solving this linear system becomes the computational bottleneck, motivating the search for more efficient solution strategies.

Recent advances in quantum computing have opened new possibilities for solving linear systems exponentially faster than classical algorithms. The Harrow-Hassidim-Lloyd (HHL) algorithm~\cite{harrow2009quantum} demonstrated that for an $N \times N$ sparse Hermitian matrix, a quantum computer can prepare a quantum state proportional to the solution vector in time polylogarithmic in $N$, compared to the polynomial time required by classical solvers. This exponential speedup has profound implications for finite element analysis, where the dimensionality of the stiffness matrix grows with the number of elements in the discretization.

This work implements a complete quantum finite element solver for the canonical problem of a cantilever beam subjected to transverse loading. The cantilever beam problem serves as an ideal test case because it combines several essential features of structural mechanics: geometric boundary conditions (fixed support), natural boundary conditions (free end), and well-established analytical solutions for verification. Moreover, the problem can be reduced to a small system suitable for current noisy intermediate-scale quantum (NISQ) devices while retaining all the essential physics of beam bending.

The implementation employs Euler-Bernoulli beam theory, which assumes that plane sections remain plane and perpendicular to the neutral axis during bending, neglecting shear deformation effects. This classical beam theory provides an excellent approximation for slender beams where the length-to-depth ratio exceeds approximately 10. The finite element discretization utilizes Hermite cubic interpolation functions to ensure $C^1$ continuity of the displacement field, a requirement for fourth-order beam equations. Each beam element contributes a $4 \times 4$ element stiffness matrix to the global assembly, with degrees of freedom representing transverse displacement $w$ and rotation $\theta$ at each node.

The quantum component of the solver implements proper quantum phase estimation (QPE) with an 8-qubit precision register, providing eigenvalue resolution on the order of $1/2^8 \approx 0.4\%$ of the eigenvalue spectrum range. These eigenvalues are subsequently inverted through controlled rotation operations in the HHL algorithm, with careful selection of the normalization constant $C = 0.9\lambda_{min}$ to avoid rotation angle saturation while maintaining high success probability. The quantum circuit executes on the Cirq state-vector simulator, achieving solution accuracy better than 0.001\% relative error compared to classical direct solvers.

\section{Finite Element Formulation for Euler-Bernoulli Beams}

The governing differential equation for the transverse deflection of a Euler-Bernoulli beam under distributed load $q(x)$ is given by the fourth-order equation:
\begin{equation}
\frac{d^2}{dx^2}\left(EI\frac{d^2w}{dx^2}\right) = q(x)
\end{equation}
where $E$ denotes Young's modulus, $I$ represents the second moment of area about the neutral axis, and $w(x)$ is the transverse displacement. For a uniform beam with constant $EI$, this simplifies to:
\begin{equation}
EI\frac{d^4w}{dx^4} = q(x)
\end{equation}

The weak form of this equation, obtained through the principle of virtual work, requires that the virtual work performed by internal bending moments equals the virtual work of external forces for all kinematically admissible virtual displacement fields. This leads to the variational statement:
\begin{equation}
\int_0^L EI\frac{d^2w}{dx^2}\frac{d^2\delta w}{dx^2}\,dx = \int_0^L q(x)\delta w\,dx + [V\delta w]_0^L + [M\delta\theta]_0^L
\end{equation}
where $\delta w$ represents the virtual displacement, $V$ denotes shear force, $M$ represents bending moment, and $\theta = dw/dx$ is the rotation angle.

The finite element discretization divides the beam domain $[0,L]$ into $n_e$ elements of length $h = L/n_e$. Within each element, the displacement field is approximated using Hermite cubic interpolation functions, which provide the necessary $C^1$ continuity across element boundaries. For a single element with nodes at $x_1$ and $x_2$, the displacement field takes the form:
\begin{equation}
w^e(\xi) = \mathbf{N}(\xi)\mathbf{u}^e = \sum_{i=1}^4 N_i(\xi)u_i^e
\end{equation}
where $\xi = (x-x_1)/h$ is the local coordinate normalized to $[0,1]$, and $\mathbf{u}^e = [w_1, \theta_1, w_2, \theta_2]^T$ contains the nodal degrees of freedom.

The Hermite shape functions are defined as:
\begin{align}
N_1(\xi) &= 1 - 3\xi^2 + 2\xi^3 \\
N_2(\xi) &= h(\xi - 2\xi^2 + \xi^3) \\
N_3(\xi) &= 3\xi^2 - 2\xi^3 \\
N_4(\xi) &= h(-\xi^2 + \xi^3)
\end{align}

These functions satisfy the interpolation properties $N_i(\xi_j) = \delta_{ij}$ and $dN_i/d\xi|_{\xi_j} = 0$ for displacement-related functions, while the derivative-related functions satisfy $N_i(\xi_j) = 0$ and $h^{-1}dN_i/d\xi|_{\xi_j} = \delta_{ij}$.

The element stiffness matrix is derived from the strain energy expression:
\begin{equation}
\mathbf{K}^e = \int_0^h EI\frac{d^2\mathbf{N}^T}{dx^2}\frac{d^2\mathbf{N}}{dx^2}\,dx
\end{equation}

Transforming to the local coordinate and performing the integration yields the $4 \times 4$ element stiffness matrix:
\begin{equation}
\mathbf{K}^e = \frac{EI}{h^3}\begin{bmatrix}
12 & 6h & -12 & 6h \\
6h & 4h^2 & -6h & 2h^2 \\
-12 & -6h & 12 & -6h \\
6h & 2h^2 & -6h & 4h^2
\end{bmatrix}
\end{equation}

This matrix exhibits the expected properties of symmetry ($\mathbf{K}^e = (\mathbf{K}^e)^T$) and positive semi-definiteness, with rank deficiency of 2 corresponding to the two rigid body modes (translation and rotation) that must be constrained through boundary conditions.

The global stiffness matrix $\mathbf{K}$ is assembled through the standard direct stiffness method, summing contributions from all elements according to the connectivity pattern. For a mesh with $n_e$ elements and $n_n = n_e + 1$ nodes, the global system has dimension $2n_n \times 2n_n$. The force vector $\mathbf{f}$ incorporates point loads applied at nodal locations, with distributed loads requiring appropriate integration over element domains.

For the cantilever beam configuration, essential boundary conditions at the fixed support ($x=0$) prescribe $w(0) = 0$ and $\theta(0) = 0$, eliminating two degrees of freedom from the system. The free end ($x=L$) has natural boundary conditions with zero moment and shear, which are automatically satisfied in the weak formulation when no concentrated loads are applied at that location. After applying the displacement boundary conditions, the reduced system becomes:
\begin{equation}
\mathbf{K}_{reduced}\mathbf{u}_{free} = \mathbf{f}_{reduced}
\end{equation}
where the subscript "free" denotes the unconstrained degrees of freedom.

For a single-element cantilever beam subjected to a tip load $P$, the reduced system has dimension $2 \times 2$:
\begin{equation}
\frac{EI}{L^3}\begin{bmatrix}
12 & 6L \\
6L & 4L^2
\end{bmatrix}\begin{bmatrix}
w_L \\
\theta_L
\end{bmatrix} = \begin{bmatrix}
P \\
0
\end{bmatrix}
\end{equation}

The analytical solution for tip deflection under this loading is $w_L = PL^3/(3EI)$, which serves as the verification benchmark for both classical and quantum solvers. The eigenvalues of the reduced stiffness matrix can be computed from the characteristic equation $\det(\mathbf{K}_{reduced} - \lambda\mathbf{I}) = 0$, yielding:
\begin{equation}
\lambda_{1,2} = \frac{EI}{L^3}\left(8L^2 \pm 2L^2\sqrt{7}\right)
\end{equation}

These eigenvalues play a crucial role in the quantum algorithm, as they determine both the rotation angles in the HHL circuit and the phase estimation precision requirements.

\section{Quantum Phase Estimation Algorithm}

Quantum phase estimation (QPE) forms the foundation of the HHL algorithm, serving to extract eigenvalues from the stiffness matrix through a quantum measurement process. The algorithm operates on a unitary operator $U = e^{i\mathbf{K}t}$, where $\mathbf{K}$ is the Hermitian stiffness matrix and $t$ is a time evolution parameter. For an eigenvector $\ket{\psi_j}$ of $\mathbf{K}$ with eigenvalue $\lambda_j$, the unitary evolves as:
\begin{equation}
U\ket{\psi_j} = e^{i\lambda_j t}\ket{\psi_j}
\end{equation}

The phase $\phi_j = \lambda_j t/(2\pi)$ (modulo 1) encodes the eigenvalue information, which QPE extracts through a quantum Fourier transform-based protocol.

The QPE circuit employs two registers: an $n$-qubit precision register initialized to $\ket{0}^{\otimes n}$ and a target register encoding the initial state $\ket{b}$ that will be a superposition of eigenvectors. The algorithm proceeds through four main stages:

First, Hadamard gates are applied to all qubits in the precision register, creating a uniform superposition $\ket{+}^{\otimes n} = (1/\sqrt{2^n})\sum_{k=0}^{2^n-1}\ket{k}$. This superposition allows the algorithm to probe all possible phase values simultaneously through quantum parallelism. Simultaneously, the target register is prepared in the state $\ket{b}$, which in the finite element context represents the normalized force vector. Since $\ket{b} = \sum_j \beta_j\ket{\psi_j}$ where $\{\ket{\psi_j}\}$ are the eigenvectors of $\mathbf{K}$ and $\beta_j = \braket{\psi_j|b}$ are the expansion coefficients, each eigenvector component will acquire its corresponding phase.

Second, controlled-$U^{2^k}$ operations are applied for $k = 0, 1, \ldots, n-1$, with the $k$-th qubit of the precision register as control. These operations implement the transformation:
\begin{equation}
\sum_{k=0}^{2^n-1}\ket{k}\ket{b} \rightarrow \sum_{k=0}^{2^n-1}\ket{k}U^k\ket{b}
\end{equation}

For the eigencomponent $\ket{\psi_j}$, this becomes:
\begin{equation}
\frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1}\ket{k}e^{i\lambda_j kt}\ket{\psi_j} = \frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1}e^{2\pi i\phi_j k}\ket{k}\ket{\psi_j}
\end{equation}

This is precisely the quantum Fourier transform of the state $\ket{\tilde{\phi_j}}$ where $\tilde{\phi_j} = 2^n\phi_j$ represents the phase in the computational basis.

Third, the inverse quantum Fourier transform (QFT$^\dagger$) is applied to the precision register. The QFT on $n$ qubits implements the transformation:
\begin{equation}
\text{QFT}\ket{j} = \frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1}e^{2\pi ijk/2^n}\ket{k}
\end{equation}

Applying the inverse operation extracts the phase estimate:
\begin{equation}
\text{QFT}^\dagger\left(\frac{1}{\sqrt{2^n}}\sum_{k=0}^{2^n-1}e^{2\pi i\phi_j k}\ket{k}\right) \approx \ket{\tilde{\phi_j}}
\end{equation}

The approximation becomes exact when $\phi_j = m/2^n$ for integer $m$, otherwise the estimate has bounded error determined by the number of precision qubits.

Fourth, measurement of the precision register in the computational basis yields an integer $m \in \{0,1,\ldots,2^n-1\}$ with probability concentrated near $m = \text{round}(2^n\phi_j)$. The eigenvalue estimate is then:
\begin{equation}
\tilde{\lambda_j} = \frac{2\pi m}{2^n t}
\end{equation}

The precision of this estimate scales as $\Delta\lambda \sim 2\pi/(2^n t)$, improving exponentially with the number of precision qubits. For the stiffness matrix with eigenvalue range $[\lambda_{min}, \lambda_{max}]$, the time parameter $t$ must be chosen to avoid phase wrapping, requiring $\lambda_{max} t < 2\pi$. The implementation uses an automatic selection scheme $t = 2\pi/(1.5\lambda_{max})$, which ensures the maximum phase stays below $2\pi/3$, providing margin for numerical errors while maintaining good resolution.

The circuit depth for QPE scales as $O(n \cdot 2^n)$ due to the controlled-$U^{2^k}$ operations, which require implementing matrix exponentiation to high powers. For the $2 \times 2$ stiffness matrices encountered in single-element cantilever beams, each controlled operation requires decomposition into single and two-qubit gates, with the complexity growing polynomially in the matrix dimension for general sparse matrices.

\section{Harrow-Hassidim-Lloyd Algorithm for Linear Systems}

The HHL algorithm solves the linear system $\mathbf{K}\mathbf{u} = \mathbf{f}$ by preparing a quantum state $\ket{u}$ whose amplitudes are proportional to the solution vector components. The algorithm combines quantum phase estimation with controlled rotation operations to implement effective matrix inversion on a quantum computer. For finite element applications, the stiffness matrix $\mathbf{K}$ is real symmetric positive definite, satisfying the Hermitian requirement for HHL.

The complete HHL circuit operates on three registers: the precision register for QPE (8 qubits in this implementation), the system register encoding the eigenvector information (1 qubit for $2 \times 2$ systems), and a single ancilla qubit that flags successful matrix inversion. The algorithm proceeds through the following stages:

\textbf{State Preparation:} The force vector $\mathbf{f} = [f_1, f_2]^T$ is encoded into a quantum state through an $R_y$ rotation on the system qubit. Normalizing $\mathbf{f}$ to unit length gives $\tilde{\mathbf{f}} = \mathbf{f}/\|\mathbf{f}\|$, which can be represented as:
\begin{equation}
\ket{b} = \cos(\theta/2)\ket{0} + \sin(\theta/2)\ket{1}
\end{equation}
where $\theta = 2\arctan(f_2/f_1)$. This state naturally decomposes in the eigenbasis as $\ket{b} = \beta_1\ket{\psi_1} + \beta_2\ket{\psi_2}$, where the coefficients $\beta_j = \braket{\psi_j|b}$ depend on the overlap between the force vector and each eigenvector.

\textbf{Eigenvalue Encoding:} For a $2 \times 2$ real symmetric matrix, the eigenvectors can be parameterized by a single angle $\theta_V$, and the eigenbasis transformation is implemented through an $R_y(-\theta_V)$ rotation. After this transformation, the computational basis states $\ket{0}$ and $\ket{1}$ correspond to the two eigenvectors. The full QPE circuit then operates in this rotated basis, applying controlled-$U^{2^k}$ operations where $U = e^{i\mathbf{K}t}$.

However, for the specific case of $2 \times 2$ systems, the implementation uses an optimized direct circuit that avoids the full QPE overhead. The eigenvalues $\lambda_1$ and $\lambda_2$ are known analytically from the matrix diagonalization, allowing controlled rotations to be applied directly based on which eigenstate the system occupies. This optimization reduces the circuit depth significantly while maintaining exact results.

\textbf{Controlled Rotation:} The key innovation of HHL is the controlled rotation that implements the mapping $\lambda_j \rightarrow 1/\lambda_j$ through the ancilla qubit. For each eigenvalue $\lambda_j$ encoded in the precision register, an $R_y$ rotation is applied to the ancilla with angle:
\begin{equation}
\theta_j = 2\arcsin\left(\frac{C}{\lambda_j}\right)
\end{equation}
where $C$ is a normalization constant satisfying $C \leq \lambda_{min}$. This rotation creates the state:
\begin{equation}
\cos(\theta_j/2)\ket{0} + \sin(\theta_j/2)\ket{1} = \sqrt{1-\frac{C^2}{\lambda_j^2}}\ket{0} + \frac{C}{\lambda_j}\ket{1}
\end{equation}

The choice of $C$ critically affects both the success probability and the accuracy of the inversion. Setting $C$ too small reduces the rotation angles, making the $\ket{1}$ amplitude vanishingly small and requiring many repeated measurements to obtain a success event. Conversely, setting $C$ too close to $\lambda_{min}$ causes the rotation angle to approach $\pi/2$, saturating the sine function and losing precision in the mapping. The implementation uses $C = 0.9\lambda_{min}$, which provides a balance between success probability (approximately 18-20\%) and numerical stability.

After applying controlled rotations for both eigenvalues, the full state becomes:
\begin{equation}
\sum_{j=1}^2 \beta_j\left(\sqrt{1-\frac{C^2}{\lambda_j^2}}\ket{0} + \frac{C}{\lambda_j}\ket{1}\right)\ket{\psi_j}
\end{equation}

Measuring the ancilla and post-selecting on the outcome $\ket{1}$ projects the system register into the state:
\begin{equation}
\ket{u} \propto \sum_{j=1}^2 \frac{\beta_j}{\lambda_j}\ket{\psi_j} = \sum_{j=1}^2 \frac{\beta_j}{\lambda_j}\ket{\psi_j}
\end{equation}

This is precisely the solution to $\mathbf{K}\ket{u} = \ket{b}$, as can be verified by applying $\mathbf{K}$:
\begin{equation}
\mathbf{K}\ket{u} = \sum_{j=1}^2 \frac{\beta_j}{\lambda_j}\mathbf{K}\ket{\psi_j} = \sum_{j=1}^2 \beta_j\ket{\psi_j} = \ket{b}
\end{equation}

The proportionality constant in equation (17) requires careful treatment to recover the correct solution magnitude. The success probability of measuring $\ket{1}$ on the ancilla is:
\begin{equation}
p_{success} = \sum_{j=1}^2 |\beta_j|^2\frac{C^2}{\lambda_j^2}
\end{equation}

The normalization of the post-selected state gives a factor of $1/\sqrt{p_{success}}$, while the actual solution magnitude is $\|\mathbf{u}\| = \|\mathbf{K}^{-1}\mathbf{f}\|$. Through quantum tomography or amplitude estimation, the relationship can be established:
\begin{equation}
\|\mathbf{u}\| = \frac{\|\mathbf{f}\|}{C}\sqrt{p_{success}}
\end{equation}

This formula allows reconstruction of the properly scaled solution vector from the quantum state amplitudes and the measured success probability.

\textbf{Uncomputation and Measurement:} After the controlled rotations, the eigenvalue information encoded in the precision register must be uncomputed by applying the inverse QPE circuit. This reverses all operations except the rotation on the ancilla, returning the precision register to $\ket{0}^{\otimes n}$ and the system register to the rotated eigenbasis. A final $R_y(\theta_V)$ rotation returns to the computational basis, where measurement yields the solution components $u_1$ and $u_2$.

The optimized implementation for $2 \times 2$ systems eliminates the uncomputation step by directly measuring the system qubit after the controlled rotations and basis transformation. This simplified circuit has depth $O(1)$ compared to the $O(n \cdot 2^n)$ depth of the full HHL circuit, making it practical for near-term quantum devices while preserving the essential algorithmic structure for educational and verification purposes.

\section{Implementation and Numerical Results}

The complete quantum finite element solver is implemented in Python using the Cirq quantum computing framework~\cite{cirq}, comprising 507 lines of code organized into four main modules. The beam finite element module (66 lines) implements the Euler-Bernoulli formulation with Hermite cubic elements, providing methods for element stiffness matrix computation, global assembly, boundary condition application, and solution reconstruction. The quantum phase estimation module (115 lines) implements the full QPE algorithm with automatic time parameter selection and configurable precision bits. The HHL solver module (124 lines) provides both the optimized $2 \times 2$ circuit and a framework for general HHL implementation. The visualization module (71 lines) exports three-dimensional beam geometries to VTK format for ParaView rendering.

The numerical test case considers a steel cantilever beam with the following properties: length $L = 1.0$ m, square cross-section with width $w = 0.1$ m, Young's modulus $E = 200$ GPa (typical for structural steel), and second moment of area $I = w^4/12 = 8.333 \times 10^{-6}$ m$^4$. A downward point load of $P = 10$ kN is applied at the free end. The analytical solution from beam theory predicts a tip deflection of:
\begin{equation}
w_L = \frac{PL^3}{3EI} = \frac{10000 \times 1^3}{3 \times 200 \times 10^9 \times 8.333 \times 10^{-6}} = 2.000 \text{ mm}
\end{equation}

The single-element finite element discretization yields the reduced stiffness matrix:
\begin{equation}
\mathbf{K}_{reduced} = \begin{bmatrix}
2.0 \times 10^7 & -1.0 \times 10^7 \\
-1.0 \times 10^7 & 6.667 \times 10^6
\end{bmatrix} \text{ N/m}
\end{equation}
with eigenvalues $\lambda_1 = 1.315 \times 10^6$ N/m and $\lambda_2 = 2.535 \times 10^7$ N/m.

Quantum phase estimation with 8 precision qubits and automatic time parameter selection ($t = 1.652 \times 10^{-7}$ s) produces eigenvalue estimates $\tilde{\lambda}_1 = 1.337 \times 10^6$ N/m and $\tilde{\lambda}_2 = 2.540 \times 10^7$ N/m, corresponding to relative errors of 1.67\% and 0.20\% respectively. The phase measurements show strong concentration around the expected values, with the most frequently measured phases occurring in approximately 70\% and 25\% of the 2000 measurement shots for the two eigenvalues. The expected phase range of $[0.0346, 0.6667]$ based on the eigenvalue spectrum is correctly captured by the QPE circuit.

The HHL algorithm, using the optimized $2 \times 2$ circuit with $C = 0.9\lambda_{min} = 1.183 \times 10^6$ N/m, produces a quantum solution state that, when decoded, yields $\mathbf{u}_{quantum} = [-2.000 \times 10^{-3}, -3.000 \times 10^{-3}]^T$ m. This matches the classical finite element solution to within numerical precision, with relative error $\|\mathbf{u}_{quantum} - \mathbf{u}_{classical}\|/\|\mathbf{u}_{classical}\| = 3 \times 10^{-6}$ or 0.0003\%. The success probability measured over 2000 circuit repetitions is 18.2\%, consistent with the theoretical prediction from equation (19).

Running with a load of $300kN$ gives the following result -
\begin{verbatim}
$ python src/quantum_fem/demo_quantum_fem_complete.py -f 300

Running: Force=300.0kN, Length=1.0m, Width=0.1m


Classical:
  Analytic: -6.000000e-02 m
  FEM:      -6.000000e-02 m

Running QPE (8-bit)...
[QPE] Auto-selected t=1.652263e-07 (L_min=1314829.0818, L_max=25351837.5849)
[QPE] Expected phase range: [0.0346, 0.6667]
  QPE eigenvalues: [ 1336913.31014015 25401352.89266294]
  True eigenvalues: [ 1314829.0817867  25351837.58487997]

Running HHL...
  Quantum solution: [-0.06000001 -0.09      ]
  Classical solution: [-0.06 -0.09]
  Error: 0.000007%
  Success probability: 18.3%

Saved results to quantum_fem_demo.png
check *vtk files for final results

  Tip deflection: 60.000 mm
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{quantum_fem_demo.png}
    \caption{Plot of results}\end{figure}
The quantum circuit executes on the Cirq state-vector simulator, which performs exact simulation of quantum evolution without noise or decoherence effects. While this provides an idealized environment for algorithm verification, extrapolation to real quantum hardware must account for gate errors, measurement errors, and finite coherence times. Current NISQ devices typically have single-qubit gate fidelities around 99.9\% and two-qubit gate fidelities around 99\%, which would introduce errors on the order of 1-10\% for circuits with depths comparable to this implementation. Error mitigation techniques such as zero-noise extrapolation and probabilistic error cancellation could reduce these errors, though at the cost of increased measurement overhead.

The visualization component generates four VTK output files representing the classical and quantum solutions at both coarse (single element) and refined (20 elements) discretizations(shown in Fig. \ref{fig:paraview-demo}, on the first page). The three-dimensional beam geometry is constructed by extruding the one-dimensional finite element mesh into a volumetric hexahedral mesh, with the deflection field mapped onto the nodal coordinates. ParaView rendering with the "Warp By Vector" filter applied at a scale factor of 1 clearly shows the characteristic cantilever deflection profile, with maximum displacement at the free end and zero displacement at the fixed support. The deformed shape closely matches the analytical cubic deflection curve predicted by beam theory.

\section{Discussion and Future Directions}

This work demonstrates that quantum algorithms can achieve solution accuracy competitive with classical methods for finite element analysis, at least for small systems amenable to exact simulation. The less than 0.001\% error observed in the quantum solution validates both the theoretical correctness of the HHL algorithm and the practical implementation details such as state preparation, controlled rotations, and amplitude extraction. However, several important limitations and opportunities for extension warrant discussion.

The primary limitation is the restriction to $2 \times 2$ systems imposed by the optimized circuit implementation. While the quantum phase estimation component is fully general and can handle arbitrary power-of-two matrix dimensions, the HHL inversion step currently uses analytical eigendecomposition and direct controlled rotations. Extending to larger systems requires implementing the full QPE-based eigenvalue encoding, controlled rotation synthesis for arbitrary precision registers, and uncomputation of the QPE circuit. These additions would increase the circuit depth to $O(n \cdot 2^n \cdot \text{poly}(\log N))$ for an $N \times N$ matrix with $n$ precision qubits, quickly exceeding the capabilities of current NISQ devices.

The success probability of 18-20\% observed in the HHL circuit, while consistent with theoretical predictions, represents a significant overhead compared to classical solvers that deterministically produce the solution. Amplitude amplification techniques based on Grover's algorithm could boost the success probability to near unity, though at the cost of increasing circuit depth by a factor of $1/\sqrt{p_{success}} \approx 2.3$ in this case. Alternative approaches such as variational quantum eigensolvers (VQE) or quantum approximate optimization algorithms (QAOA) might achieve higher success rates through different algorithmic strategies, though generally without the exponential speedup of HHL.

The eigenvalue conditioning of the stiffness matrix plays a crucial role in both classical and quantum solution accuracy. The condition number $\kappa = \lambda_{max}/\lambda_{min} \approx 19.3$ for the test case is relatively benign, but realistic finite element models often exhibit condition numbers in the range $10^3$-$10^{12}$ depending on mesh refinement and element aspect ratios. High condition numbers cause small eigenvalues to require very small rotation angles in the HHL circuit, reducing the $\ket{1}$ amplitude on the ancilla and decreasing success probability. Preconditioning techniques that transform the system to improve conditioning may be essential for practical quantum finite element analysis, though designing effective quantum preconditioners remains an active research area.

The quantum resource requirements scale unfavorably compared to classical methods for small to medium-sized problems. The 8-qubit QPE register, 1-qubit system register, and 1-qubit ancilla total 10 qubits for a $2 \times 2$ system, with circuit depth on the order of 100-200 gates including all controlled operations and QFT stages. Classical direct solvers can handle systems up to $N \sim 10^6$ on modern workstations, while quantum advantage likely requires $N \gtrsim 10^9$ based on current complexity analyses~\cite{aaronson2015read}. This crossover point is far beyond the capabilities of near-term quantum devices, suggesting that quantum finite element methods will remain primarily of theoretical and educational interest until fault-tolerant quantum computers with millions of logical qubits become available.

Nevertheless, several promising research directions emerge from this implementation. First, hybrid classical-quantum algorithms that use quantum computers for specific bottleneck operations (such as eigenvalue computation or subspace projection) while retaining classical solvers for the bulk computation may achieve speedups on nearer-term hardware. Second, problem-specific encoding schemes that exploit the sparsity structure of finite element matrices could reduce qubit requirements or circuit depth. Third, application to time-dependent problems such as structural dynamics or transient heat transfer, where the same stiffness matrix is inverted repeatedly for different forcing vectors, could amortize the quantum circuit overhead across many time steps.

From a mechanical engineering perspective, the quantum approach illuminates fundamental connections between structural mechanics and quantum mechanics. The eigenvalue problem $\mathbf{K}\mathbf{u} = \lambda\mathbf{u}$ that arises in free vibration analysis is mathematically identical to the time-independent Schrödinger equation $\hat{H}\ket{\psi} = E\ket{\psi}$, with the stiffness matrix playing the role of the Hamiltonian operator. The principle of virtual work, which underlies the finite element method, parallels the variational principle used to derive the Schrödinger equation from the action integral. These formal similarities suggest that insights from quantum mechanics, such as perturbation theory or adiabatic evolution, might find analogs in computational mechanics.

\section{Conclusion}

This report has presented a complete implementation of quantum finite element analysis for cantilever beam problems, combining classical Euler-Bernoulli beam theory with quantum phase estimation and the HHL algorithm. The finite element discretization using Hermite cubic elements produces a symmetric positive definite stiffness matrix suitable for quantum linear system solvers. Quantum phase estimation with 8 precision qubits achieves eigenvalue accuracy better than 2\%, while the HHL circuit produces solution vectors matching classical results to within 0.001\% relative error. The 507-line Python implementation using the Cirq framework demonstrates the practical feasibility of quantum algorithms for structural mechanics on near-term quantum simulators.

While current limitations in qubit count, coherence time, and gate fidelity restrict quantum finite element methods to small demonstration problems, the exponential speedup promised by the HHL algorithm motivates continued research toward fault-tolerant quantum computers. The techniques developed in this work—automatic QPE parameter selection, optimized HHL circuits for small systems, and quantum-classical solution verification—provide a foundation for future implementations on real quantum hardware. As quantum computing technology matures, these algorithms may eventually enable finite element analysis of problems currently intractable on classical computers, opening new frontiers in computational mechanics.

\begin{thebibliography}{9}

\bibitem{harrow2009quantum}
A. W. Harrow, A. Hassidim, and S. Lloyd,
\textit{Quantum algorithm for linear systems of equations},
Physical Review Letters, \textbf{103}(15), 150502, 2009.

\bibitem{cirq}
Cirq Developers,
\textit{Cirq: A Python framework for creating, editing, and invoking Noisy Intermediate Scale Quantum (NISQ) circuits},
2021. [Online]. Available: \url{https://github.com/quantumlib/Cirq}

\bibitem{aaronson2015read}
S. Aaronson,
\textit{Read the fine print},
Nature Physics, \textbf{11}(4), pp. 291-293, 2015.

\bibitem{nielsen2000quantum}
M. A. Nielsen and I. L. Chuang,
\textit{Quantum Computation and Quantum Information},
Cambridge University Press, 2000.

\bibitem{bathe2006finite}
K. J. Bathe,
\textit{Finite Element Procedures},
Prentice Hall, 2006.

\bibitem{clader2013preconditioned}
B. D. Clader, B. C. Jacobs, and C. R. Sprouse,
\textit{Preconditioned quantum linear system algorithm},
Physical Review Letters, \textbf{110}(25), 250504, 2013.

\bibitem{montanaro2015quantum}
A. Montanaro,
\textit{Quantum algorithms: an overview},
npj Quantum Information, \textbf{2}, 15023, 2016.

\bibitem{dervovic2018quantum}
D. Dervovic, M. Herbster, P. Mountney, S. Severini, N. Usher, and L. Wossnig,
\textit{Quantum linear systems algorithms: a primer},
arXiv preprint arXiv:1802.08227, 2018.

\bibitem{zhao2024quantum}
Y. Zhao, X. Gao, J. Chen, and X. Peng,
\textit{Quantum finite element method for structural mechanics},
arXiv preprint arXiv:2403.19512, 2024.

\end{thebibliography}

\appendix
\section{Quantum Circuit Diagrams}

\begin{figure}[H]
\centering
\begin{quantikz}
\lstick{$\ket{0}^{\otimes 8}$} & \gate{H} & \ctrl{1} & \ctrl{1} & \ctrl{1} & \cdots & \ctrl{1} & \gate[8]{\text{QFT}^\dagger} & \meter{} \\
\lstick{$\ket{0}^{\otimes 8}$} & \gate{H} & \qw & \ctrl{1} & \qw & \cdots & \ctrl{1} & \qw & \meter{} \\
\lstick{\vdots} & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\lstick{$\ket{b}$} & \qw & \gate{U} & \gate{U^2} & \gate{U^4} & \cdots & \gate{U^{2^7}} & \qw & \qw
\end{quantikz}
\caption{Quantum Phase Estimation circuit with 8 precision qubits. The state register is initialized to $\ket{b}$ (the normalized force vector), while the precision register begins in $\ket{0}^{\otimes 8}$. After Hadamard gates create superposition, controlled-$U^{2^k}$ operations entangle the registers. The inverse QFT extracts phase information, which is measured to obtain eigenvalue estimates.}
\end{figure}

\begin{figure}[H]
\centering
\begin{quantikz}
\lstick{$\ket{0}$} & \gate{R_y(\theta_b)} & \gate{R_y(-\theta_V)} & \gate{X} & \ctrl{1} & \gate{X} & \ctrl{1} & \gate{R_y(\theta_V)} & \qw & \qw \\
\lstick{$\ket{0}$} & \qw & \qw & \qw & \gate{R_y(\theta_1)} & \qw & \gate{R_y(\theta_2)} & \qw & \meter{} & \qw
\end{quantikz}
\caption{Optimized HHL circuit for $2 \times 2$ systems. The system qubit is prepared in state $\ket{b}$ through $R_y(\theta_b)$, then rotated to the eigenbasis with $R_y(-\theta_V)$. Controlled rotations on the ancilla implement eigenvalue inversion: $\theta_j = 2\arcsin(C/\lambda_j)$. Success is indicated by measuring the ancilla in state $\ket{1}$.}
\end{figure}

\end{document}

